
title: S.E.H 终极防护:SEHOP、

date: 2018-03-16

categories: 
- 《0day2》

#  0x00 EHOP 的原理

SEHOP 的核心任务就是检查这条 S.E.H 链的完整性，在程序转入异常处理前 SEHOP 会检 14 查 S.E.H 链上最后一个异常处理函数是否为系统固定的终极异常处理函数。

如果是，则说明这条 S.E.H 链没有被破坏，程序可以去执行当前的异常处理函数;

如果检测到最后一个异常处理 函数不是终极 BOSS，则说明 S.E.H 链被破坏，可能发生了 S.E.H 覆盖攻击，程序将不会去执 行当前的异常处理函数

![seh_o](sehop/seh_o.png)

理论上我们还有是三条路可以走，他们分别是:

(1)不去攻击 S.E.H，而是攻击函数返回地址或者虚函数等。 

(2)利用未启用 SEHOP 的模块。

(3)伪造 S.E.H 链。

# 0x01 攻击返回地址



# 0x02 攻击虚函数



# 0x03 利用未启用 SEHOP 的模块

出于兼容性的考虑还是对一些程序禁用 了 SEHOP，如经过 Armadilo 加壳的软件。

操作系统会根据 PE 头中 MajorLinkerVersion 和 MinorLinkerVersion 两个选项来判断是否为程序禁用SEHOP。

我们可以将这两个选项分别设置为0x53和0x52来模拟经过Armadilo 加壳的程序，从而达到禁用 SEHOP 的目的。

思路和  “利用未启用 SafeSEH 模块” 一样。



# 0x04 伪造 S.E.H 链表

SEHOP 的原理就是检测 S.E.H 链中最后一个异常处理函数指针是否指向一个固定的终极异 常处理函数，如果我们溢出时伪造这样一个结构就可以绕过 SEHOP 了。

要实现 S.E.H 的伪造是非常困难的事，首先它有着一个非常苛刻的前提——系统的 ASLR 不能启用。

![sehop](sehop/sehop.png)



































